import Mathlib

section missing_instance
/-

Andrew's definition of the algebra structure on `HomogeneousLocalization 𝒜 S`.

-/
open HomogeneousLocalization in
instance {R A ι : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq ι]
  [AddCommMonoid ι] (𝒜 : ι → Submodule R A) [GradedAlgebra 𝒜] (S : Submonoid A) :
    Algebra R (HomogeneousLocalization 𝒜 S) :=
  ((fromZeroRingHom 𝒜 S).comp (algebraMap _ _)).toAlgebra

@[simp]
lemma HomogeneousLocalization.algebraMap_eq
  {R A ι : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq ι]
  [AddCommMonoid ι] (𝒜 : ι → Submodule R A) [GradedAlgebra 𝒜] (S : Submonoid A) :
    algebraMap R (HomogeneousLocalization 𝒜 S) = ((fromZeroRingHom 𝒜 S).comp (algebraMap _ _)) := rfl

end missing_instance

noncomputable section statement

variable {R₀ S : Type}
variable [CommRing R₀] [CommRing S] [Algebra R₀ S]
variable (𝒜 : ℕ → Submodule R₀ S) [GradedAlgebra 𝒜]

instance : Algebra (𝒜 0) S := (SetLike.GradeZero.subalgebra 𝒜).toAlgebra
variable [Algebra.FiniteType (𝒜 0) S]

/-

## Generation of S by homogeneous elements

By definition `S = ⨁ᵢ (𝒜 i)` is a graded ring (graded by `ℕ`) and
in particular `S` is an `𝒜 0`-algebra.

By assumption `S` is finitely-generated `𝒜 0`-algebra.

What we next claim is that `S` is generated by finitely many *homogeneous*
elements of `S`.

-/

-- S is finitely-generated over 𝒜 0
example : ∃ (F : Set S),
    (F.Finite) ∧ (Algebra.adjoin (𝒜 0) F = ⊤) := by
  obtain ⟨F, hF⟩ := Algebra.FiniteType.out (R := 𝒜 0) (A := S)
  exact ⟨F, F.finite_toSet, hF⟩

-- But we need homogeneous generators.
theorem FG_by_homogeneous : ∃ (F : Set S),
    (F.Finite) ∧
    (Algebra.adjoin (𝒜 0) F = ⊤) ∧
    (∀ f ∈ F, ∃ n : ℕ, f ∈ 𝒜 n) := by
  sorry

open HomogeneousLocalization

/-

## S_{(f)} is an 𝒜₀-algebra

Although S_{(f)} isn't an S-algebra (because S has
stuff in degree not zero but S_{(f)} is only degree 0 stuff)

-/

variable {d : ℕ}
variable {f : S} (hf : f ∈ 𝒜 d)

--#synth Algebra (𝒜 0) (Away 𝒜 f)

variable {A : Type} [CommRing A] [IsDomain A] [ValuationRing A]
variable {K : Type} [Field K] [Algebra A K] [IsFractionRing A K]

/-
The diagram in the question

                  φ
              K <--- S(f)
              /\      /\
     canonical|       |canonical
              |       |
              A <---- 𝒜₀
                  φ₀
-/

variable [Algebra (𝒜 0) A] -- φ
variable [Algebra (Away 𝒜 f) K] -- φ₀
variable [Algebra (𝒜 0) K] -- the diagonal
  -- bottom triangle commutes
  [IsScalarTower (𝒜 0) A K]
  -- top triangle commutes
  -- **TODO** need to fix this
  --[IsScalarTower (𝒜 0) (Away 𝒜 f) K]

theorem projective_implies_proper_aux : ∃ (x₀ : S) (e : ℕ) (he : 0 < e) (h₀ : x₀ ∈ 𝒜 e)
    (φ' : Away 𝒜 x₀ →+* A), φ'.comp (algebraMap R₀ (Away 𝒜 x₀)) = algebraMap R₀ A := by
  sorry

end statement
