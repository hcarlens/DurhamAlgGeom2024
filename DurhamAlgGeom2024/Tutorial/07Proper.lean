import Mathlib
import DurhamAlgGeom2024.Tutorial.«06Separated»
section missing_instance
/-

Andrew's definition of the algebra structure on `HomogeneousLocalization 𝒜 S`.

-/
open HomogeneousLocalization in
instance {R A ι : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq ι]
  [AddCommMonoid ι] (𝒜 : ι → Submodule R A) [GradedAlgebra 𝒜] (S : Submonoid A) :
    Algebra R (HomogeneousLocalization 𝒜 S) :=
  ((fromZeroRingHom 𝒜 S).comp (algebraMap _ _)).toAlgebra

@[simp]
lemma HomogeneousLocalization.algebraMap_eq
  {R A ι : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq ι]
  [AddCommMonoid ι] (𝒜 : ι → Submodule R A) [GradedAlgebra 𝒜] (S : Submonoid A) :
    algebraMap R (HomogeneousLocalization 𝒜 S) = ((fromZeroRingHom 𝒜 S).comp (algebraMap _ _)) := rfl

end missing_instance

noncomputable section statement

variable {R₀ S : Type}
variable [CommRing R₀] [CommRing S] [Algebra R₀ S]
variable (𝒜 : ℕ → Submodule R₀ S) [GradedAlgebra 𝒜]

instance : Algebra (𝒜 0) S := (SetLike.GradeZero.subalgebra 𝒜).toAlgebra
variable [Algebra.FiniteType (𝒜 0) S]

/-

## Generation of S by homogeneous elements

By definition `S = ⨁ᵢ (𝒜 i)` is a graded ring (graded by `ℕ`) and
in particular `S` is an `𝒜 0`-algebra.

By assumption `S` is finitely-generated `𝒜 0`-algebra.

What we next claim is that `S` is generated by finitely many *homogeneous*
elements of `S`.

-/

-- S is finitely-generated over 𝒜 0
example : ∃ (F : Set S),
    (F.Finite) ∧ (Algebra.adjoin (𝒜 0) F = ⊤) := by
  obtain ⟨F, hF⟩ := Algebra.FiniteType.out (R := 𝒜 0) (A := S)
  exact ⟨F, F.finite_toSet, hF⟩

-- But we need homogeneous generators.
-- This preliminary version gives homogeneous generators
-- but allows generators in degree 0
theorem FG_by_homogeneous₀ : ∃ (ι₀ : Type) (x : ι₀ → S) (_ : Fintype ι₀),
    (Algebra.adjoin (𝒜 0) (Set.range x) = ⊤) ∧
    (∀ i : ι₀, ∃ n : ℕ, x i ∈ 𝒜 n) := by
  classical
  -- S is finitely-generated
  obtain ⟨F, hF⟩ := Algebra.FiniteType.out (R := 𝒜 0) (A := S)
  -- ι₀ is pairs (s,n) such that s ∈ F and sₙ ≠ 0
  let ι₀ := Σ (x : F), (DirectSum.decompose 𝒜 x.1).support
  -- x(s,n) is sₙ
  let x (i : ι₀) : S := ((DirectSum.decompose 𝒜) i.1 i.2).1
  -- This should work
  refine ⟨ι₀, x, inferInstance, ?_, ?_⟩
  · rw [← top_le_iff, ← hF]
    apply Algebra.adjoin_le
    -- STP that if s ∈ F then s ∈ 𝒜₀[tₘ] for t running through F
    intro s hs
    -- Well s = ∑ₙ sₙ
    rw [← DirectSum.sum_support_decompose 𝒜 s]
    -- so it suffices that ∀ n, sₙ ∈ 𝒜₀[tₘ]
    apply sum_mem
    intro n hn
    -- so it suffices that sₙ is one of the tₘ
    apply Algebra.subset_adjoin
    -- but this is obvious
    use ⟨⟨s, hs⟩, n, hn⟩
  · rintro ⟨f, nf⟩
    use nf
    exact ((DirectSum.decompose 𝒜) f nf).2

theorem FG_by_homogeneous : ∃ (ι : Type) (x : ι → S) (_ : Fintype ι),
    (Algebra.adjoin (𝒜 0) (Set.range x) = ⊤) ∧
    (∀ i : ι, ∃ n : ℕ, 0 < n ∧ x i ∈ 𝒜 n) := by
  obtain ⟨ι₀, x, _, h1, h2⟩ := FG_by_homogeneous₀ 𝒜
  choose n hn using h2
  use {i : ι₀ // 0 < n i}
  use fun j ↦ x j.1
  use inferInstance
  refine ⟨?_, ?_⟩
  · rw [← top_le_iff, ← h1]
    apply Algebra.adjoin_le
    rintro s ⟨i, rfl⟩
    by_cases hi : 0 < n i
    · apply Algebra.subset_adjoin
      use ⟨i, hi⟩
    · have hi0 : n i = 0 := by omega
      exact Subalgebra.algebraMap_mem
        (Algebra.adjoin (↥(𝒜 0)) (Set.range fun (j : {i : ι₀ // 0 < n i}) ↦ x j)) ⟨x i, hi0 ▸ hn i⟩
  · rintro ⟨i, hi⟩
    use n i, hi
    apply hn

open HomogeneousLocalization

/-

## S_{(f)} is an 𝒜₀-algebra

Although S_{(f)} isn't an S-algebra (because S has
stuff in degree not zero but S_{(f)} is only degree 0 stuff)

-/

variable {d : ℕ}
variable {f : S} (hf : f ∈ 𝒜 d)

--#synth Algebra (𝒜 0) (Away 𝒜 f)

variable {A : Type} [CommRing A] [IsDomain A] [ValuationRing A]
variable {K : Type} [Field K] [Algebra A K] [IsFractionRing A K]

/-
The diagram in the question

                  φ
              K <--- S(f)
              /\      /\
     canonical|       |canonical
              |       |
              A <---- 𝒜₀
                  φ₀
-/

variable (φ₀ : (𝒜 0) →+* A)
variable (φ : (Away 𝒜 f) →+* K)
variable (hcomm : (algebraMap A K).comp φ₀ = φ.comp (fromZeroRingHom 𝒜 _))

theorem projective_implies_proper_aux : ∃ (x₀ : S) (e : ℕ) (he : 0 < e)
    (h₀ : x₀ ∈ 𝒜 e)
    (φ' : Away 𝒜 (f * x₀) →+* K),
    (φ'.comp (map2 𝒜 h₀ rfl) = φ) ∧
    Set.range (φ'.comp (map2 𝒜 hf (mul_comm f x₀))) ⊆ Set.range (algebraMap A K) := by
  classical
  obtain ⟨ι, x, h1, h2, h3⟩:= FG_by_homogeneous 𝒜
  choose di hdi hxdi using h3
  let ψ: (i : ι) → ValuationRing.ValueGroup A K :=
    fun i ↦ ValuationRing.valuation A K <| (φ (mk {
      deg := d * di i
      num := ⟨x i ^d, SetLike.pow_mem_graded d (hxdi i) ⟩
      den := ⟨f^(di i) , mul_comm d (di i) ▸ SetLike.pow_mem_graded (di i) ( hf)⟩
      den_mem := ⟨_, rfl⟩
    }))^ ∏ j in Finset.univ.erase i, di j
  cases isEmpty_or_nonempty ι
  · sorry
  · have foo : (Finset.image ψ Finset.univ).Nonempty := by rwa [Finset.image_nonempty, Finset.univ_nonempty_iff]
    set Kmax := Finset.max' (Finset.image ψ Finset.univ) foo
    have : Kmax ∈ _ := Finset.max'_mem (Finset.image ψ Finset.univ) foo
    simp only [Finset.mem_image, Finset.mem_univ, true_and] at this
    obtain ⟨i0, hi0⟩ := this
    have hi0 : ∀ (j : ι), ψ j ≤ ψ i0 := by
      intro j
      rw [hi0]
      exact Finset.le_max' (Finset.image ψ Finset.univ) (ψ j) (by simp)
    use x i0
    use di i0
    use hdi i0
    use hxdi i0
    sorry

end statement
